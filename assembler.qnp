import "string.qnp"
import "stdio.qnp"

import "errorhandler.qnp"

enum InsCode:
    none,
    add, sub,
    and, or, xor,
    jz, jnz, jgz, jlz, jge, jle,
    jrz, jrnz, jrgz, jrlz, jrge, jrle,
    st, ld,
    lui, lli, li

enum OpCode:
    none = 0b111111,
    add  = 0b00000,
    sub  = 0b00001,
    and  = 0b00010,
    or   = 0b00011,
    xor  = 0b00100,
    jxx  = 0b00101,
    st   = 0b00110,
    ld   = 0b00111,
    lui  = 0b01000,
    lli  = 0b01001,
    li   = 0b01010

enum InsType:
    none,
    threeArg,
    condBranch,
    memRead,
    memWrite,
    immLoad

enum RegID:
    zero = 0b0000,
    gp   = 0b0001,
    sp   = 0b0010,
    bp   = 0b0011,
    ra   = 0b0100,
    r0   = 0b0101,
    r1   = 0b0110,
    r2   = 0b0111,
    r3   = 0b1000,
    r4   = 0b1001,
    r5   = 0b1010,
    r6   = 0b1011,
    r7   = 0b1100,
    r8   = 0b1101,
    r9   = 0b1110,
    r10  = 0b1111,
    none = 0b11111

enum CondID:
    z, nz,
    gz, lz,
    ge, le

enum OffsetType:
    normal,
    short,
    longContinuous,
    longSplit

pack ArgParseData:
    var<RegID> register
    var<i32> offset
    var<bool> hasOffset
    var<bool> offsetAlreadyUsed

pack AssemblerData:
    var<std.String const*> code
    var<std.String const*> filename
    var<bool> verbose
    var<u64> line
    var<u64> column
    var<u64> codeIndex
    var<u64> codeLength
    var<u64> nInstructions
    var<u32*> instructions
    var<bool> errorOccurred
    var<std.String*> entrypointName

fn<InsCode> insCodeFromStr(std.String const* str):
    if str->equals("add"): return InsCode.add
    if str->equals("sub"): return InsCode.sub
    if str->equals("and"): return InsCode.and
    if str->equals("or"): return InsCode.or
    if str->equals("xor"): return InsCode.xor
    if str->equals("jz"): return InsCode.jz
    if str->equals("jnz"): return InsCode.jnz
    if str->equals("jgz"): return InsCode.jgz
    if str->equals("jlz"): return InsCode.jlz
    if str->equals("jge"): return InsCode.jge
    if str->equals("jle"): return InsCode.jle
    if str->equals("jrz"): return InsCode.jrz
    if str->equals("jrnz"): return InsCode.jrnz
    if str->equals("jrgz"): return InsCode.jrgz
    if str->equals("jrlz"): return InsCode.jrlz
    if str->equals("jrge"): return InsCode.jrge
    if str->equals("jrle"): return InsCode.jrle
    if str->equals("st"): return InsCode.st
    if str->equals("ld"): return InsCode.ld
    if str->equals("lui"): return InsCode.lui
    if str->equals("lli"): return InsCode.lli
    if str->equals("li"): return InsCode.li
    return InsCode.none

fn<OpCode> opCodeFromInsCode(InsCode ic):
    if ic == InsCode.add: return OpCode.add
    if ic == InsCode.sub: return OpCode.sub
    if ic == InsCode.and: return OpCode.and
    if ic == InsCode.or: return OpCode.or
    if ic == InsCode.xor: return OpCode.xor
    if ic == InsCode.jz || ic == InsCode.jnz || \
        ic == InsCode.jgz || ic == InsCode.jlz || \
        ic == InsCode.jge || ic == InsCode.jle || \
        ic == InsCode.jrz || ic == InsCode.jrnz || \
        ic == InsCode.jrgz || ic == InsCode.jrlz || \
        ic == InsCode.jrge || ic == InsCode.jrle:
        return OpCode.jxx
    if ic == InsCode.st: return OpCode.st
    if ic == InsCode.ld: return OpCode.ld
    if ic == InsCode.lui: return OpCode.lui
    if ic == InsCode.lli: return OpCode.lli
    if ic == InsCode.li: return OpCode.li
    return OpCode.none

fn<InsType> insTypeFromOpCode(OpCode oc):
    if oc == OpCode.add || oc == OpCode.sub || \
        oc == OpCode.and || oc == OpCode.or || oc == OpCode.xor:
        return InsType.threeArg
    if oc == OpCode.jxx:
        return InsType.condBranch
    if oc == OpCode.st:
        return InsType.memWrite
    if oc == OpCode.ld:
        return InsType.memRead
    if oc == OpCode.lui || oc == OpCode.lli || oc == OpCode.li:
        return InsType.immLoad

    handleMsgError("(internal): unknown opcode!")
    return InsType.none

fn<RegID> regIDFromStr(std.String const* str):
    if str->equals("zero"): return RegID.zero
    if str->equals("gp"): return RegID.gp
    if str->equals("sp"): return RegID.sp
    if str->equals("bp"): return RegID.bp
    if str->equals("ra"): return RegID.ra
    if str->equals("r0"): return RegID.r0
    if str->equals("r1"): return RegID.r1
    if str->equals("r2"): return RegID.r2
    if str->equals("r3"): return RegID.r3
    if str->equals("r4"): return RegID.r4
    if str->equals("r5"): return RegID.r5
    if str->equals("r6"): return RegID.r6
    if str->equals("r7"): return RegID.r7
    if str->equals("r8"): return RegID.r8
    if str->equals("r9"): return RegID.r9
    if str->equals("r10"): return RegID.r10
    return RegID.none

fn<u64> lineCount(std.String const* code):
    var<u64> count = 1
    var<u64> i = 0
    var<u64> codeLength = code->length()
    while i < codeLength:
        if code->at(i) == '\n':
            ++count
        ++i
    return count

fn<bool> parseWhitespace(AssemblerData* data):
    var<bool> parsedWhitespace = false
    while std.isspace(data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        parsedWhitespace = true

    return parsedWhitespace

fn<bool> parseExact(AssemblerData* data, u8 const* str):
    var<u64> i = 0
    var<u64> strLength = std.strlen(str)
    while i < strLength:
        if data->code->at(data->codeIndex + i) != str[i]:
            return false
        ++i
    data->codeIndex += strLength
    data->column += strLength
    return true

fn<bool> parseNewline(AssemblerData* data):
    if data->code->at(data->codeIndex) != '\n':
        return false

    ++data->codeIndex
    ++data->line
    data->column = 1
    return true

fn<bool> parseEntrypoint(AssemblerData* data):
    if !parseExact(data, "."):
        return false

    if !parseExact(data, "entry"):
        handleAsmError("expected 'entry' after '.'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    if !parseWhitespace(data):
        handleAsmError("expected whitespace after '.entry'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c
    var name = std.new(std.String)
    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    if name->length() == 0:
        handleAsmError("expected entrypoint name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after entrypoint name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    data->entrypointName = name
    
    return true

fn<bool> parseLabel(AssemblerData* data):
    if !parseExact(data, ":"):
        return false
    
    if !parseExact(data, ":"):
        handleAsmError("expected ':' after ':'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c
    var name = std.new(std.String)

    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    if name->length() == 0:
        handleAsmError("expected label name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after label name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    \\ TODO: Add label to symbol table

    return true

fn<InsCode> parseInsCode(AssemblerData* data):
    var insStr = std.new(std.String)

    var<u8> c
    var<u64> i = 0
    while std.isalnum(c = data->code->at(data->codeIndex + i)):
        insStr->push_back(c)
        ++i

    var insCode = insCodeFromStr(insStr)
    std.delete(insStr)

    if insCode == InsCode.none:
        return InsCode.none

    data->codeIndex += i
    data->column += i

    return insCode

fn<bool> parseReg(AssemblerData* data, ArgParseData* apd):
    if !parseWhitespace(data):
        handleAsmError("Expected whitespace before register name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var name = std.new(std.String)
    var<u8> c
    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    apd->register = regIDFromStr(name)
    std.delete(name)

    if apd->register == RegID.none:
        handleAsmError("expected register name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    return true

fn<bool> parseRegOffset(AssemblerData* data, ArgParseData* apd):
    if !parseReg(data, apd):
        return false

    if !parseExact(data, "("):
        apd->hasOffset = false
        return true

    if apd->offsetAlreadyUsed:
        handleAsmError("instructions may not have more than one offset specified!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    apd->offsetAlreadyUsed = true
    apd->hasOffset = true

    var offStr = std.new(std.String)
    var<u8> c
    while std.isnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        offStr->push_back(c)

    if offStr->beginswith("0x"):
        apd->offset = std.stoi(offStr->raw() + 2, 16)
    elif offStr->beginswith("0b"):
        apd->offset = std.stoi(offStr->raw() + 2, 2)
    elif offStr->beginswith("0"):
        apd->offset = std.stoi(offStr->raw() + 1, 8)
    else:
        apd->offset = std.stoi(offStr->raw(), 10)

    if !parseExact(data, ")"):
        handleAsmError("expected ')' after offset!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    return true

fn<> writeInsPart(AssemblerData* data, ?T part, u32 mask, u32 offset):
    data->instructions[data->nInstructions] |= (((u32)part) & mask) << offset

fn<> writeInsOpCode(AssemblerData* data, OpCode oc):
    writeInsPart(data, oc, 0b11111, 0)

fn<> writeInsDestReg(AssemblerData* data, RegID rid):
    writeInsPart(data, rid, 0b1111, 5)

fn<> writeInsCondition(AssemblerData* data, CondID cid):
    writeInsPart(data, cid, 0b1111, 5)

fn<> writeInsOffsetSelect(AssemblerData* data, i32 os):
    writeInsPart(data, os, 0b1, 9)

fn<> writeInsSourceReg1(AssemblerData* data, RegID rid):
    writeInsPart(data, rid, 0b1111, 10)

fn<> writeInsSourceReg2(AssemblerData* data, RegID rid):
    writeInsPart(data, rid, 0b1111, 14)

fn<> writeInsOffset(AssemblerData* data, i32 offset, OffsetType ot):
    if ot == OffsetType.normal:
        writeInsPart(data, offset, 0b11111111111111, 18)
    elif ot == OffsetType.short:
        writeInsPart(data, offset, 0b1111111111111, 18)
    elif ot == OffsetType.longContinuous:
        writeInsPart(data, offset, 0b111111111111111111, 14)
    elif ot == OffsetType.longSplit:
        writeInsPart(data, offset, 0b1111, 5)
        writeInsPart(data, offset >> 5, 0b11111111111111, 18)

fn<> writeInsRelativeJump(AssemblerData* data, i32 rj):
    writeInsPart(data, rj, 0b1, 31)

fn<> writeInsImmediate(AssemblerData* data, i32 imm):
    writeInsPart(data, imm, 0b11111111111111111111111, 9)

fn<bool> parseInstructionThreeArg(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.offset = 0
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    if !parseReg(data, &apd):
        return false

    writeInsDestReg(data, apd.register)
    
    if !parseRegOffset(data, &apd):
        return false

    writeInsSourceReg1(data, apd.register)
    if apd.hasOffset:
        writeInsOffsetSelect(data, 0)
        writeInsOffset(data, apd.offset, OffsetType.normal)

    if !parseRegOffset(data, &apd):
        return false

    writeInsSourceReg2(data, apd.register)
    if apd.hasOffset:
        writeInsOffsetSelect(data, 1)
        writeInsOffset(data, apd.offset, OffsetType.normal)

    return true

fn<bool> parseInstructionCondBranch(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionMemRead(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionMemWrite(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionImmLoad(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstruction(AssemblerData* data):
    var insCode = parseInsCode(data)
    if insCode == InsCode.none:
        return false

    var opCode = opCodeFromInsCode(insCode)
    data->instructions[data->nInstructions] = 0
    writeInsOpCode(data, opCode)

    var insType = insTypeFromOpCode(opCode)
    
    var<bool> success

    if insType == InsType.threeArg:
        success =  parseInstructionThreeArg(data, insCode)
    elif insType == InsType.condBranch:
        success = parseInstructionCondBranch(data, insCode)
    elif insType == InsType.memRead:
        success = parseInstructionMemRead(data, insCode)
    elif insType == InsType.memWrite:
        success = parseInstructionMemWrite(data, insCode)
    elif insType == InsType.immLoad:
        success = parseInstructionImmLoad(data, insCode)
    else:
        handleAsmError("(internal): instruction type not implemented!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        success = false

    if success:
        ++data->nInstructions

    return success

fn<bool> parseComment(AssemblerData* data):
    if !parseExact(data, "~"):
        return false

    if !parseExact(data, "~"):
        handleAsmError("expected '~' after '~'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c

    while (c = data->code->at(data->codeIndex)) != '\n' && c != '\0':
        ++data->codeIndex
        ++data->column

    parseNewline(data)

    return true



fn<u32*> assemble(std.String const* code, std.String const* filename, bool verbose, u64* pnInstructionsOut):
    var<AssemblerData> data
    data.code = code
    data.filename = filename
    data.verbose = verbose
    data.line = 1
    data.column = 1
    data.codeIndex = 0
    data.codeLength = code->length()
    data.nInstructions = 0
    data.errorOccurred = false
    data.entrypointName = null

    var buffSize = lineCount(code) * 4
    if verbose: std.println("Allocating % bytes of instruction memory...", buffSize)
    data.instructions = (u32*)std.malloc(buffSize)
    if data.instructions == null:
        handleMsgError("failed to allocate instruction memory")
        return null

    while data.codeIndex < data.codeLength:
        parseWhitespace(&data)

        if parseNewline(&data): continue
        if data.errorOccurred: break
        
        if parseEntrypoint(&data): continue
        if data.errorOccurred: break
        
        if parseLabel(&data): continue
        if data.errorOccurred: break
        
        if parseInstruction(&data): continue
        if data.errorOccurred: break
        
        if parseComment(&data): continue
        if data.errorOccurred: break
        
        return handleAsmError("unexpected character!", data.filename, data.line, data.column, data.instructions)
    
    if data.errorOccurred:
        std.free(data.instructions)
        return null

    *pnInstructionsOut = data.nInstructions

    return data.instructions