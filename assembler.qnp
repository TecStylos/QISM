import "string.qnp"
import "stdio.qnp"

import "errorhandler.qnp"

enum InsCode:
    none,
    add, sub,
    and, or, xor,
    jz, jnz, jgz, jlz, jge, jle,
    jrz, jrnz, jrgz, jrlz, jrge, jrle,
    st, ld,
    lui, lli, li

enum OpCode:
    none = 0b111111,
    add  = 0b00000,
    sub  = 0b00001,
    and  = 0b00010,
    or   = 0b00011,
    xor  = 0b00100,
    jxx  = 0b00101,
    st   = 0b00110,
    ld   = 0b00111,
    lui  = 0b01000,
    lli  = 0b01001,
    li   = 0b01010

enum InsType:
    none,
    threeArg,
    condBranch,
    memRead,
    memWrite,
    immLoad

fn<InsCode> insCodeFromStr(std.String* str):
    if str->equals("add"): return InsCode.add
    if str->equals("sub"): return InsCode.sub
    if str->equals("and"): return InsCode.and
    if str->equals("or"): return InsCode.or
    if str->equals("xor"): return InsCode.xor
    if str->equals("jz"): return InsCode.jz
    if str->equals("jnz"): return InsCode.jnz
    if str->equals("jgz"): return InsCode.jgz
    if str->equals("jlz"): return InsCode.jlz
    if str->equals("jge"): return InsCode.jge
    if str->equals("jle"): return InsCode.jle
    if str->equals("jrz"): return InsCode.jrz
    if str->equals("jrnz"): return InsCode.jrnz
    if str->equals("jrgz"): return InsCode.jrgz
    if str->equals("jrlz"): return InsCode.jrlz
    if str->equals("jrge"): return InsCode.jrge
    if str->equals("jrle"): return InsCode.jrle
    if str->equals("st"): return InsCode.st
    if str->equals("ld"): return InsCode.ld
    if str->equals("lui"): return InsCode.lui
    if str->equals("lli"): return InsCode.lli
    if str->equals("li"): return InsCode.li
    return InsCode.none

fn<OpCode> opCodeFromInsCode(InsCode ic):
    if ic == InsCode.add: return OpCode.add
    if ic == InsCode.sub: return OpCode.sub
    if ic == InsCode.and: return OpCode.and
    if ic == InsCode.or: return OpCode.or
    if ic == InsCode.xor: return OpCode.xor
    if ic == InsCode.jz || ic == InsCode.jnz || \
        ic == InsCode.jgz || ic == InsCode.jlz || \
        ic == InsCode.jge || ic == InsCode.jle || \
        ic == InsCode.jrz || ic == InsCode.jrnz || \
        ic == InsCode.jrgz || ic == InsCode.jrlz || \
        ic == InsCode.jrge || ic == InsCode.jrle:
        return OpCode.jxx
    if ic == InsCode.st: return OpCode.st
    if ic == InsCode.ld: return OpCode.ld
    if ic == InsCode.lui: return OpCode.lui
    if ic == InsCode.lli: return OpCode.lli
    if ic == InsCode.li: return OpCode.li
    return OpCode.none

fn<InsType> insTypeFromOpCode(OpCode oc):
    if oc == OpCode.add || oc == OpCode.sub || \
        oc == OpCode.and || oc == OpCode.or || oc == OpCode.xor:
        return InsType.threeArg
    if oc == OpCode.jxx:
        return InsType.condBranch
    if oc == OpCode.st:
        return InsType.memWrite
    if oc == OpCode.ld:
        return InsType.memRead
    if oc == OpCode.lui || oc == OpCode.lli || oc == OpCode.li:
        return InsType.immLoad

    handleMsgError("(internal): unknown opcode!")
    return InsType.none

fn<u64> lineCount(std.String const* code):
    var<u64> count = 1
    var<u64> i = 0
    var<u64> codeLength = code->length()
    while i < codeLength:
        if code->at(i) == '\n':
            ++count
        ++i
    return count

pack AssemblerData:
    var<std.String const*> code
    var<std.String const*> filename
    var<bool> verbose
    var<u64> line
    var<u64> column
    var<u64> codeIndex
    var<u64> codeLength
    var<u64*> pnInstructions
    var<u32*> instructions
    var<bool> errorOccurred
    var<std.String*> entrypointName

fn<bool> parseWhitespace(AssemblerData* data):
    var<bool> parsedWhitespace = false
    while std.isspace(data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        parsedWhitespace = true

    return parsedWhitespace

fn<bool> parseExact(AssemblerData* data, u8 const* str):
    var<u64> i = 0
    var<u64> strLength = std.strlen(str)
    while i < strLength:
        if data->code->at(data->codeIndex + i) != str[i]:
            return false
        ++i
    data->codeIndex += strLength
    data->column += strLength
    return true

fn<bool> parseNewline(AssemblerData* data):
    if data->code->at(data->codeIndex) != '\n':
        return false

    ++data->codeIndex
    ++data->line
    data->column = 1
    return true

fn<bool> parseEntrypoint(AssemblerData* data):
    if !parseExact(data, "."):
        return false

    if !parseExact(data, "entry"):
        handleAsmError("expected 'entry' after '.'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    if !parseWhitespace(data):
        handleAsmError("expected whitespace after '.entry'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c
    var name = std.new(std.String)
    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    if name->length() == 0:
        handleAsmError("expected entrypoint name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after entrypoint name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    data->entrypointName = name
    
    return true

fn<bool> parseLabel(AssemblerData* data):
    if !parseExact(data, ":"):
        return false
    
    if !parseExact(data, ":"):
        handleAsmError("expected ':' after ':'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c
    var name = std.new(std.String)

    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    if name->length() == 0:
        handleAsmError("expected label name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after label name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    \\ TODO: Add label to symbol table

    return true

fn<InsCode> parseInsCode(AssemblerData* data):
    var insStr = std.new(std.String)

    var<u8> c
    var<u64> i = 0
    while std.isalnum(c = data->code->at(data->codeIndex + i)):
        insStr->push_back(c)
        ++i

    var insCode = insCodeFromStr(insStr)
    std.delete(insStr)

    if insCode == InsCode.none:
        return InsCode.none

    data->codeIndex += i
    data->column += i

    return insCode

fn<bool> parseInstructionThreeArg(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionCondBranch(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionMemRead(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionMemWrite(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstructionImmLoad(AssemblerData* data, InsCode ic):
    return false

fn<bool> parseInstruction(AssemblerData* data):
    var insCode = parseInsCode(data)
    if insCode == InsCode.none:
        return false

    var opCode = opCodeFromInsCode(insCode)

    var insType = insTypeFromOpCode(opCode)
    
    if insType == InsType.threeArg:
        return parseInstructionThreeArg(data, insCode)
    if insType == InsType.condBranch:
        return parseInstructionCondBranch(data, insCode)
    if insType == InsType.memRead:
        return parseInstructionMemRead(data, insCode)
    if insType == InsType.memWrite:
        return parseInstructionMemWrite(data, insCode)
    if insType == InsType.immLoad:
        return parseInstructionImmLoad(data, insCode)

    handleAsmError("(internal): instruction type not implemented!", data->filename, data->line, data->column, data->instructions)
    data->errorOccurred = true
    return false

fn<bool> parseComment(AssemblerData* data):
    if !parseExact(data, "~"):
        return false

    if !parseExact(data, "~"):
        handleAsmError("expected '~' after '~'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c

    while (c = data->code->at(data->codeIndex)) != '\n' && c != '\0':
        ++data->codeIndex
        ++data->column

    parseNewline(data)

    return true



fn<u32*> assemble(std.String const* code, std.String const* filename, bool verbose, u64* pnInstructionsOut):
    var<AssemblerData> data
    data.code = code
    data.filename = filename
    data.verbose = verbose
    data.line = 1
    data.column = 1
    data.codeIndex = 0
    data.codeLength = code->length()
    data.pnInstructions = pnInstructionsOut
    *data.pnInstructions = 0
    data.errorOccurred = false
    data.entrypointName = null

    var buffSize = lineCount(code) * 4
    if verbose: std.println("Allocating % bytes of instruction memory...", buffSize)
    data.instructions = (u32*)std.malloc(buffSize)
    if data.instructions == null:
        handleMsgError("failed to allocate instruction memory")
        return null

    while data.codeIndex < data.codeLength:
        parseWhitespace(&data)

        if parseNewline(&data): continue
        if data.errorOccurred: break
        
        if parseEntrypoint(&data): continue
        if data.errorOccurred: break
        
        if parseLabel(&data): continue
        if data.errorOccurred: break
        
        if parseInstruction(&data): continue
        if data.errorOccurred: break
        
        if parseComment(&data): continue
        if data.errorOccurred: break
        
        return handleAsmError("unexpected character!", data.filename, data.line, data.column, data.instructions)
    
    if data.errorOccurred:
        std.free(data.instructions)
        return null

    return data.instructions