import "string.qnp"
import "stdio.qnp"
import "map.qnp"
import "list.qnp"

import "errorhandler.qnp"

enum InsCode:
    none,
    add, sub,
    and, or, xor,
    shl, shr,
    jz, jnz, jgz, jlz, jge, jle,
    jrz, jrnz, jrgz, jrlz, jrge, jrle,
    st, ld,
    lui, lli, li

enum OpCode:
    none = 0b111111,
    add  = 0b00000,
    sub  = 0b00001,
    and  = 0b00010,
    or   = 0b00011,
    xor  = 0b00100,
    shl  = 0b00101,
    shr  = 0b00110,
    jxx  = 0b00111,
    st   = 0b01000,
    ld   = 0b01001,
    lui  = 0b01010,
    lli  = 0b01011,
    li   = 0b01100

enum InsType:
    none,
    threeArg,
    condBranch,
    memRead,
    memWrite,
    immLoad

enum RegID:
    zero = 0b0000,
    gp   = 0b0001,
    sp   = 0b0010,
    bp   = 0b0011,
    ra   = 0b0100,
    r0   = 0b0101,
    r1   = 0b0110,
    r2   = 0b0111,
    r3   = 0b1000,
    r4   = 0b1001,
    r5   = 0b1010,
    r6   = 0b1011,
    r7   = 0b1100,
    rinp = 0b1101,
    rssd = 0b1110,
    rled = 0b1111,
    none = 0b11111

enum CondID:
    z  = 0b0000,
    nz = 0b0001,
    gz = 0b0010,
    lz = 0b0011,
    ge = 0b0100,
    le = 0b0101,
    none = 0b11111

enum OffsetType:
    none,
    normal,
    short,
    longContinuous,
    longSplit

enum LiteralMode:
    Default,
    Upper,
    Lower,
    Relative

enum LiteralInsertMode:
    none,
    imm16,
    imm23,
    offNormal,
    offShort,
    offLongContinuous,
    offLongSplit

pack LiteralInfo:
    var<LiteralMode> mode
    var<LiteralInsertMode> insertMode
    var<i32> value
    var<std.String*> label
    var<u32> insIndex
    var<u32> line
    var<u32> column

pack ArgParseData:
    var<RegID> register
    var<bool> hasOffset
    var<bool> offsetAlreadyUsed

pack ParityInstruction:
    var<u32> line
    var<u32> instruction

pack AssemblerData:
    var<std.String const*> code
    var<std.String const*> filename
    var<bool> verbose
    var<bool> addAnnotations
    var<u64> line
    var<u64> column
    var<u64> codeIndex
    var<u64> codeLength
    var<u64> nInstructions
    var<u32*> instructions
    var<ParityInstruction*> parityInstructions
    var<std.String**> annotations
    var<std.String*> entrypointName
    var<std.Map*> labels
    var<std.List*> literals

fn<> freeAsmData(AssemblerData* data):
    std.free(data->instructions)
    std.free(data->entrypointName)
    if data->annotations != null:
        var i = 0
        while i < data->nInstructions:
            std.delete(data->annotations[i])
            ++i
        std.free(data->annotations)

fn<LiteralInsertMode> litInsModeFromOffsetType(OffsetType ot) nodiscard:
    if ot == OffsetType.normal: return LiteralInsertMode.offNormal
    if ot == OffsetType.short: return LiteralInsertMode.offShort
    if ot == OffsetType.longContinuous: return LiteralInsertMode.offLongContinuous
    if ot == OffsetType.longSplit: return LiteralInsertMode.offLongSplit
    return LiteralInsertMode.none

fn<OffsetType> offsetTypeFromLitInsMode(LiteralInsertMode lim) nodiscard:
    if lim == LiteralInsertMode.offNormal: return OffsetType.normal
    if lim == LiteralInsertMode.offShort: return OffsetType.short
    if lim == LiteralInsertMode.offLongContinuous: return OffsetType.longContinuous
    if lim == LiteralInsertMode.offLongSplit: return OffsetType.longSplit
    return OffsetType.none

fn<InsCode> insCodeFromStr(std.String const* str) nodiscard:
    if str->equals("add"): return InsCode.add
    if str->equals("sub"): return InsCode.sub
    if str->equals("and"): return InsCode.and
    if str->equals("or"): return InsCode.or
    if str->equals("xor"): return InsCode.xor
    if str->equals("shl"): return InsCode.shl
    if str->equals("shr"): return InsCode.shr
    if str->equals("jz"): return InsCode.jz
    if str->equals("jnz"): return InsCode.jnz
    if str->equals("jgz"): return InsCode.jgz
    if str->equals("jlz"): return InsCode.jlz
    if str->equals("jge"): return InsCode.jge
    if str->equals("jle"): return InsCode.jle
    if str->equals("jrz"): return InsCode.jrz
    if str->equals("jrnz"): return InsCode.jrnz
    if str->equals("jrgz"): return InsCode.jrgz
    if str->equals("jrlz"): return InsCode.jrlz
    if str->equals("jrge"): return InsCode.jrge
    if str->equals("jrle"): return InsCode.jrle
    if str->equals("st"): return InsCode.st
    if str->equals("ld"): return InsCode.ld
    if str->equals("lui"): return InsCode.lui
    if str->equals("lli"): return InsCode.lli
    if str->equals("li"): return InsCode.li
    return InsCode.none

fn<OpCode> opCodeFromInsCode(InsCode ic) nodiscard:
    if ic == InsCode.add: return OpCode.add
    if ic == InsCode.sub: return OpCode.sub
    if ic == InsCode.and: return OpCode.and
    if ic == InsCode.or: return OpCode.or
    if ic == InsCode.xor: return OpCode.xor
    if ic == InsCode.shl: return OpCode.shl
    if ic == InsCode.shr: return OpCode.shr
    if ic == InsCode.jz || ic == InsCode.jnz || \
        ic == InsCode.jgz || ic == InsCode.jlz || \
        ic == InsCode.jge || ic == InsCode.jle || \
        ic == InsCode.jrz || ic == InsCode.jrnz || \
        ic == InsCode.jrgz || ic == InsCode.jrlz || \
        ic == InsCode.jrge || ic == InsCode.jrle:
        return OpCode.jxx
    if ic == InsCode.st: return OpCode.st
    if ic == InsCode.ld: return OpCode.ld
    if ic == InsCode.lui: return OpCode.lui
    if ic == InsCode.lli: return OpCode.lli
    if ic == InsCode.li: return OpCode.li
    return OpCode.none

fn<InsType> insTypeFromOpCode(OpCode oc) nodiscard:
    if oc == OpCode.add || oc == OpCode.sub || \
        oc == OpCode.and || oc == OpCode.or || oc == OpCode.xor || \
        oc == OpCode.shl || oc == OpCode.shr:
        return InsType.threeArg
    if oc == OpCode.jxx:
        return InsType.condBranch
    if oc == OpCode.st:
        return InsType.memWrite
    if oc == OpCode.ld:
        return InsType.memRead
    if oc == OpCode.lui || oc == OpCode.lli || oc == OpCode.li:
        return InsType.immLoad

    handleMsgError("(internal): unknown opcode!")
    return InsType.none

fn<RegID> regIDFromStr(std.String const* str) nodiscard:
    if str->equals("zero"): return RegID.zero
    if str->equals("gp"): return RegID.gp
    if str->equals("sp"): return RegID.sp
    if str->equals("bp"): return RegID.bp
    if str->equals("ra"): return RegID.ra
    if str->equals("r0"): return RegID.r0
    if str->equals("r1"): return RegID.r1
    if str->equals("r2"): return RegID.r2
    if str->equals("r3"): return RegID.r3
    if str->equals("r4"): return RegID.r4
    if str->equals("r5"): return RegID.r5
    if str->equals("r6"): return RegID.r6
    if str->equals("r7"): return RegID.r7
    if str->equals("rinp"): return RegID.rinp
    if str->equals("rssd"): return RegID.rssd
    if str->equals("rled"): return RegID.rled
    return RegID.none

fn<bool> isRelativeJump(InsCode ic) nodiscard:
    return ic == InsCode.jrz || ic == InsCode.jrnz || \
        ic == InsCode.jrgz || ic == InsCode.jrlz || \
        ic == InsCode.jrge || ic == InsCode.jrle

fn<bool> isAbsoluteJump(InsCode ic) nodiscard:
    return ic == InsCode.jz || ic == InsCode.jnz || \
        ic == InsCode.jgz || ic == InsCode.jlz || \
        ic == InsCode.jge || ic == InsCode.jle

fn<CondID> conditionFromInsCode(InsCode ic) nodiscard:
    if ic == InsCode.jz || ic == InsCode.jrz:
        return CondID.z
    if ic == InsCode.jnz || ic == InsCode.jrnz:
        return CondID.nz
    if ic == InsCode.jgz || ic == InsCode.jrgz:
        return CondID.gz
    if ic == InsCode.jlz || ic == InsCode.jrlz:
        return CondID.lz
    if ic == InsCode.jge || ic == InsCode.jrge:
        return CondID.ge
    if ic == InsCode.jle || ic == InsCode.jrle:
        return CondID.le

    return CondID.none

fn<u64> lineCount(std.String const* code) nodiscard:
    var<u64> count = 1
    var<u64> i = 0
    var<u64> codeLength = code->length()
    while i < codeLength:
        if code->at(i) == '\n':
            ++count
        ++i
    return count

fn<bool> parseWhitespace(AssemblerData* data):
    var<bool> parsedWhitespace = false
    while std.isspace(data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        parsedWhitespace = true

    return parsedWhitespace

fn<bool> parseExact(AssemblerData* data, u8 const* str) nodiscard:
    var<u64> i = 0
    var<u64> strLength = std.strlen(str)
    while i < strLength:
        if data->code->at(data->codeIndex + i) != str[i]:
            return false
        ++i
    data->codeIndex += strLength
    data->column += strLength
    return true

fn<bool> parseNewline(AssemblerData* data) nodiscard:
    if data->code->at(data->codeIndex) != '\n':
        return false

    ++data->codeIndex
    ++data->line
    data->column = 1
    return true

fn<std.String*> parseAlNum(AssemblerData* data, bool allowNegative) nodiscard:
    var str = std.new(std.String)

    if allowNegative && data->code->at(data->codeIndex) == '-':
        str->push_back('-')
        ++data->codeIndex
        ++data->column

    var<u8> c
    while std.isalnum(c = data->code->at(data->codeIndex)):
        str->push_back(c)
        ++data->codeIndex
        ++data->column

    return str

fn<bool> parseEntrypoint(AssemblerData* data) nodiscard:
    if !parseExact(data, "."):
        return false

    if !parseExact(data, "entry"):
        handleAsmError("expected 'entry' after '.'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    if data->entrypointName != null:
        handleAsmError("entrypoint already defined!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    if !parseWhitespace(data):
        handleAsmError("expected whitespace after '.entry'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var name = parseAlNum(data, false)

    if name->length() == 0:
        handleAsmError("expected entrypoint name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after entrypoint name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    data->entrypointName = name

    if data->verbose:
        std.println("info: entrypoint set to '%'", name->raw())
    
    return true

fn<bool> parseLabel(AssemblerData* data) nodiscard:
    if !parseExact(data, ":"):
        return false
    
    if !parseExact(data, ":"):
        handleAsmError("expected ':' after ':'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var name = parseAlNum(data, false)

    if name->length() == 0:
        handleAsmError("expected label name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after label name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var<u32> address = data->nInstructions * 4

    if data->labels->contains(name):
        handleAsmError("label '%' already defined!", data->filename, data->line, data->column, data->instructions, name->raw())
        std.exit(1)

    data->labels->insert(name, (void*)address)

    if data->verbose:
        std.println("info: label '%' has address 0x%x", name->raw(), address)

    return true

fn<InsCode> parseInsCode(AssemblerData* data) nodiscard:
    var oldIndex = data->codeIndex
    var oldColumn = data->column

    var insStr = parseAlNum(data, false)

    var insCode = insCodeFromStr(insStr)
    std.delete(insStr)

    if insCode == InsCode.none:
        data->codeIndex = oldIndex
        data->column = oldColumn
        return InsCode.none

    return insCode

fn<> parseReg(AssemblerData* data, ArgParseData* apd):
    if !parseWhitespace(data):
        handleAsmError("Expected whitespace before register name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var name = parseAlNum(data, false)

    apd->register = regIDFromStr(name)
    std.delete(name)

    if apd->register == RegID.none:
        handleAsmError("expected register name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

fn<> parseLiteral(AssemblerData* data, LiteralInsertMode lim):
    var litInfo = (LiteralInfo*)std.malloc(sizeof(LiteralInfo))

    litInfo->mode = LiteralMode.Default
    litInfo->insertMode = lim
    litInfo->insIndex = data->nInstructions
    litInfo->line = data->line
    litInfo->column = data->column
    litInfo->label = null

    var str = parseAlNum(data, true)

    if str->equals("upr"):
        litInfo->mode = LiteralMode.Upper
        std.delete(str)
        if !parseWhitespace(data):
            handleAsmError("expected whitespace after 'upr'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        str = parseAlNum(data, true)
    elif str->equals("lwr"):
        litInfo->mode = LiteralMode.Lower
        std.delete(str)
        if !parseWhitespace(data):
            handleAsmError("expected whitespace after 'lwr'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        str = parseAlNum(data, true)
    elif str->equals("rel"):
        litInfo->mode = LiteralMode.Relative
        std.delete(str)
        if !parseWhitespace(data):
            handleAsmError("expected whitespace after 'rel'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        str = parseAlNum(data, true)

    if str->length() == 0:
        handleAsmError("expected literal!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)
    elif std.isalpha(str->at(0)):
        litInfo->label = str
    else:
        std.error.clear()

        if str->beginswith("0x"):
            litInfo->value = std.stoi(str->raw() + 2, 16)
        elif str->beginswith("0b"):
            litInfo->value = std.stoi(str->raw() + 2, 2)
        elif str->beginswith("0"):
            litInfo->value = std.stoi(str->raw() + 1, 8)
        else:
            litInfo->value = std.stoi(str->raw(), 10)

        if std.error.get() != std.error.ID.Success:
            handleAsmError("invalid literal '%'", data->filename, data->line, data->column, data->instructions, str->raw())
            std.exit(1)

    data->literals->push_back(litInfo)

fn<> parseRegOffset(AssemblerData* data, ArgParseData* apd, OffsetType ot):
    parseReg(data, apd)

    if !parseExact(data, "("):
        apd->hasOffset = false
        return

    if apd->offsetAlreadyUsed:
        handleAsmError("instructions may not have more than one offset specified!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    apd->offsetAlreadyUsed = true
    apd->hasOffset = true
    parseLiteral(data, litInsModeFromOffsetType(ot))

    if !parseExact(data, ")"):
        handleAsmError("expected ')' after offset!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

fn<> writeInsPart(AssemblerData* data, ?T part, u32 mask, u32 offset):
    var<u32> overlap = data->parityInstructions[data->nInstructions].instruction & (mask << offset)
    if overlap != 0:
        handleAsmError("(internal): instruction bit overlap! (overlap: %b+8f0 %b+8f0 %b+8f0 %b+8f0)", data->filename, data->line, data->column, data->instructions, (overlap >> 24) & 0xFF, (overlap >> 16) & 0xFF, (overlap >> 8) & 0xFF, overlap & 0xFF)
        std.exit(1)

    var rawPart = (u32)part
    var writablePart = (rawPart & mask) << offset
    
    var instr = data->instructions[data->nInstructions]
    instr &= ~(mask << offset)
    instr |= writablePart
    data->instructions[data->nInstructions] = instr
    data->parityInstructions[data->nInstructions].instruction |= mask << offset

fn<> writeInsOpCode(AssemblerData* data, OpCode oc):
    writeInsPart(data, oc, 0b11111, 0)

fn<> writeInsDestReg(AssemblerData* data, RegID rid):
    writeInsPart(data, rid, 0b1111, 5)

fn<> writeInsCondition(AssemblerData* data, CondID cid):
    if cid == CondID.none:
        handleAsmError("unknown condition!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    writeInsPart(data, cid, 0b1111, 5)

fn<> writeInsOffsetSelect(AssemblerData* data, i32 os):
    writeInsPart(data, os, 0b1, 9)

fn<> writeInsOffset(AssemblerData* data, i32 offset, OffsetType ot):    
    if ot == OffsetType.normal:
        writeInsPart(data, offset, 0b11111111111111, 18)
    elif ot == OffsetType.short:
        writeInsPart(data, offset, 0b1111111111111, 18)
    elif ot == OffsetType.longContinuous:
        writeInsPart(data, offset, 0b111111111111111111, 14)
    elif ot == OffsetType.longSplit:
        writeInsPart(data, offset, 0b1111, 5)
        writeInsPart(data, offset >> 4, 0b11111111111111, 18)
    else:
        handleAsmError("unknown offset type %!", data->filename, data->line, data->column, data->instructions, (i32)ot)
        std.exit(1)

fn<> writeInsAutoFillOffset(AssemblerData* data, ArgParseData const* apd, OffsetType ot):
    if apd->offsetAlreadyUsed:
        return
    
    writeInsOffsetSelect(data, 0)
    writeInsOffset(data, 0, ot)

fn<> writeInsSourceReg1(AssemblerData* data, ArgParseData const* apd):
    writeInsPart(data, apd->register, 0b1111, 10)
    if apd->hasOffset:
        writeInsOffsetSelect(data, 0b0)

fn<> writeInsSourceReg2(AssemblerData* data, ArgParseData const* apd):
    writeInsPart(data, apd->register, 0b1111, 14)
    if apd->hasOffset:
        writeInsOffsetSelect(data, 0b1)

fn<> writeInsRelativeJump(AssemblerData* data, i32 rj):
    writeInsPart(data, rj, 0b1, 31)

fn<> writeInsImmediate(AssemblerData* data, i32 imm):
    writeInsPart(data, imm, 0b11111111111111111111111, 9)

fn<> parseInstructionThreeArg(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    parseReg(data, &apd)
    writeInsDestReg(data, apd.register)
    
    parseRegOffset(data, &apd, OffsetType.normal)
    writeInsSourceReg1(data, &apd)

    parseRegOffset(data, &apd, OffsetType.normal)
    writeInsSourceReg2(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.normal)

fn<> parseInstructionCondBranch(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    writeInsCondition(data, conditionFromInsCode(ic))

    parseRegOffset(data, &apd, OffsetType.short)
    writeInsSourceReg1(data, &apd)

    parseRegOffset(data, &apd, OffsetType.short)
    writeInsSourceReg2(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.short)

    if isRelativeJump(ic):
        writeInsRelativeJump(data, 1)
    else:
        writeInsRelativeJump(data, 0)

fn<> parseInstructionMemRead(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    parseReg(data, &apd)

    writeInsDestReg(data, apd.register)

    parseRegOffset(data, &apd, OffsetType.longContinuous)

    writeInsOffsetSelect(data, 0)
    
    writeInsSourceReg1(data, &apd)

fn<> parseInstructionMemWrite(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false
    
    parseRegOffset(data, &apd, OffsetType.longSplit)
    writeInsSourceReg1(data, &apd)
    
    parseRegOffset(data, &apd, OffsetType.longSplit)
    writeInsSourceReg2(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.longSplit)

fn<> parseImmediate(AssemblerData* data, ArgParseData* apd, bool is16BitBound):
    parseLiteral(data, is16BitBound ? LiteralInsertMode.imm16 : LiteralInsertMode.imm23)

fn<> parseInstructionImmLoad(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false
    
    parseReg(data, &apd)
    writeInsDestReg(data, apd.register)

    parseImmediate(data, &apd, ic == InsCode.lui || ic == InsCode.lli)

fn<bool> parseInstruction(AssemblerData* data) nodiscard:
    var<u64> lineBegin = data->codeIndex

    var insCode = parseInsCode(data)
    if insCode == InsCode.none:
        return false

    var opCode = opCodeFromInsCode(insCode)
    data->parityInstructions[data->nInstructions].line = data->line
    data->parityInstructions[data->nInstructions].instruction = 0
    writeInsOpCode(data, opCode)

    var insType = insTypeFromOpCode(opCode)
    if insType == InsType.threeArg:
        parseInstructionThreeArg(data, insCode)
    elif insType == InsType.condBranch:
        parseInstructionCondBranch(data, insCode)
    elif insType == InsType.memRead:
        parseInstructionMemRead(data, insCode)
    elif insType == InsType.memWrite:
        parseInstructionMemWrite(data, insCode)
    elif insType == InsType.immLoad:
        parseInstructionImmLoad(data, insCode)
    else:
        handleAsmError("(internal): instruction type not implemented!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var<u64> lineEnd = data->codeIndex

    if data->addAnnotations:
        data->annotations[data->nInstructions] = std.new(std.String, data->code->raw() + lineBegin, lineEnd - lineBegin)
    ++data->nInstructions

    if !parseNewline(data):
        handleAsmError("expected newline after instruction", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    return true

fn<bool> parseComment(AssemblerData* data) nodiscard:
    if !parseExact(data, "~"):
        return false

    if !parseExact(data, "~"):
        handleAsmError("expected '~' after '~'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    while data->code->at(data->codeIndex) != '\n':
        ++data->codeIndex
        ++data->column

    if !parseNewline(data):
        handleAsmError("expected newline after comment", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    return true

fn<> checkLiteralRange(i32 value, LiteralInsertMode lim, AssemblerData* data, u32 line, u32 column):
    var<u32> minVal = 0
    var<u32> maxVal = 0

    if lim == LiteralInsertMode.imm16:
        minVal = -32768 \\ -2 ** 15
        maxVal =  32767 \\ 2 ** 15 - 1
    elif lim == LiteralInsertMode.imm23:
        minVal = -4194304 \\ -2 ** 22
        maxVal =  4194303 \\ 2 ** 22 - 1
    elif lim == LiteralInsertMode.offNormal:
        minVal = -8192 \\  -2 ** 13
        maxVal =  8191 \\   2 ** 13 - 1
    elif lim == LiteralInsertMode.offShort:
        minVal = -4096 \\  -2 ** 12
        maxVal =  4095 \\   2 ** 12 - 1
    elif lim == LiteralInsertMode.offLongContinuous || \
        lim == LiteralInsertMode.offLongSplit:
        minVal = -131072 \\  -2 ** 17
        maxVal =  131071 \\   2 ** 17 - 1
    else:
        handleAsmError("(internal): literal insert mode not implemented!", data->filename, line, column, data->instructions)
        std.exit(1)


    if value < minVal || value > maxVal:
        handleAsmError("literal value '%' out of range (% to %)", data->filename, line, column, data->instructions, value, minVal, maxVal)
        std.exit(1)

fn<> insertLiterals(AssemblerData* data):
    var nInstructionsBackup = data->nInstructions

    while !data->literals->empty():
        var litInfo = data->literals->pop_front({LiteralInfo*})

        data->line = litInfo->line
        data->column = litInfo->column
        data->nInstructions = litInfo->insIndex

        var<i32> value = litInfo->value
        if litInfo->label != null:
            if data->labels->contains(litInfo->label):
                value = (i32)data->labels->get(litInfo->label)
            else:
                handleAsmError("label '%' not found", data->filename, data->line, data->column, data->instructions, litInfo->label->raw())
                std.exit(1)

        if litInfo->mode == LiteralMode.Upper:
            value = (value >> 16) & 0xFFFF
        elif litInfo->mode == LiteralMode.Lower:
            value = value & 0xFFFF
        elif litInfo->mode == LiteralMode.Relative:
            value = value - (data->nInstructions * 4)

        checkLiteralRange(value, litInfo->insertMode, data, data->line, data->column)

        if litInfo->insertMode == LiteralInsertMode.imm16 || \
            litInfo->insertMode == LiteralInsertMode.imm23:
            writeInsImmediate(data, value)
        else:
            writeInsOffset(data, value, offsetTypeFromLitInsMode(litInfo->insertMode))

        std.free(litInfo)

    std.delete(data->literals)
    data->nInstructions = nInstructionsBackup

fn<> checkParity(AssemblerData* data):
    \\ Check parity of all instructions
    var i = 0
    while i < data->nInstructions:
        var instruction = data->parityInstructions[i].instruction
        if instruction != 0xFFFFFFFF:
            handleAsmError("(internal): parity bit mismatch! (%b+8f0 %b+8f0 %b+8f0 %b+8f0 -- 0 indicates unset bit)", data->filename, data->parityInstructions[i].line, 1, data->instructions, (instruction >> 24) & 0xFF, (instruction >> 16) & 0xFF, (instruction >> 8) & 0xFF, instruction & 0xFF)
            std.exit(1)
        ++i
    std.free(data->parityInstructions)

fn<> assemble(AssemblerData* data):
    data->line = 1
    data->column = 1
    data->codeIndex = 0
    data->codeLength = data->code->length()
    data->nInstructions = 0
    data->instructions = null
    data->annotations = null
    data->entrypointName = null
    data->labels = std.new(std.Map, \
        lambda<bool>(void const* a, void const* b): \
            return ((std.String const*)a)->compare((std.String const*)b) == std.Order.Less;, \
        lambda<void>(void* key): \
            std.delete((std.String*)key);, \
        lambda<void>(void* value): \
            pass; \
        )
    data->literals = std.new(std.List)

    var lc = lineCount(data->code)
    var instrBuffSize = lc * 4
    if data->verbose: std.println("info: allocating % bytes of instruction memory...", instrBuffSize)
    data->instructions = (u32*)std.malloc(instrBuffSize)
    if data->instructions == null:
        handleMsgError("failed to allocate instruction memory")
        std.exit(1)

    var parityBuffSize = lc * sizeof(ParityInstruction)
    if data->verbose: std.println("info: allocating % bytes of parity instruction memory...", parityBuffSize)
    data->parityInstructions = (ParityInstruction*)std.malloc(parityBuffSize)
    if data->parityInstructions == null:
        handleMsgError("failed to allocate parity instruction memory")
        std.exit(1)

    if data->addAnnotations:
        var annotBuffSize = lc * sizeof(std.String*)
        if data->verbose: std.println("info: allocating % bytes of annotation memory...", annotBuffSize)
        data->annotations = (std.String**)std.malloc(annotBuffSize)
        if data->annotations == null:
            handleMsgError("failed to allocate instruction line memory")
            std.exit(1)

    while data->codeIndex < data->codeLength:
        parseWhitespace(data)

        if parseNewline(data): continue
        if parseEntrypoint(data): continue
        if parseLabel(data): continue
        if parseInstruction(data): continue
        if parseComment(data): continue
        
        handleAsmError("unexpected character!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    if data->entrypointName == null:
        handleMsgError("no entrypoint specified!")
        std.exit(1)

    if data->verbose: std.println("info: inserting literals...")
    insertLiterals(data)

    if data->verbose: std.println("info: checking parity...")
    checkParity(data)