import "string.qnp"
import "stdio.qnp"

import "errorhandler.qnp"

enum OpCode:
    none,
    add, sub,
    and, or, xor,
    jz, jnz, jgz, jlz, jge, jle,
    jrz, jrnz, jrgz, jrlz, jrge, jrle,
    st, ld,
    lui, lli, li

enum ArgType:
    none,
    plainReg,
    offsetReg,
    imm

fn<OpCode> opCodeFromStr(std.String* str):
    if str->equals("add"): return OpCode.add
    if str->equals("sub"): return OpCode.sub
    if str->equals("and"): return OpCode.and
    if str->equals("or"): return OpCode.or
    if str->equals("xor"): return OpCode.xor
    if str->equals("jz"): return OpCode.jz
    if str->equals("jnz"): return OpCode.jnz
    if str->equals("jgz"): return OpCode.jgz
    if str->equals("jlz"): return OpCode.jlz
    if str->equals("jge"): return OpCode.jge
    if str->equals("jle"): return OpCode.jle
    if str->equals("jrz"): return OpCode.jrz
    if str->equals("jrnz"): return OpCode.jrnz
    if str->equals("jrgz"): return OpCode.jrgz
    if str->equals("jrlz"): return OpCode.jrlz
    if str->equals("jrge"): return OpCode.jrge
    if str->equals("jrle"): return OpCode.jrle
    if str->equals("st"): return OpCode.st
    if str->equals("ld"): return OpCode.ld
    if str->equals("lui"): return OpCode.lui
    if str->equals("lli"): return OpCode.lli
    if str->equals("li"): return OpCode.li
    return OpCode.none

fn<ArgType const*> argTypesFromOpCode(OpCode oc):
    static<ArgType[5]> argTypes
    if oc == OpCode.add || oc == OpCode.sub || \
        oc == OpCode.and || oc == OpCode.or || oc == OpCode.xor:
        argTypes[0] = ArgType.plainReg
        argTypes[1] = ArgType.offsetReg
        argTypes[2] = ArgType.offsetReg
        argTypes[3] = ArgType.none
    elif oc == OpCode.jz || oc == OpCode.jnz || \
        oc == OpCode.jgz || oc == OpCode.jlz || \
        oc == OpCode.jge || oc == OpCode.jle || \
        oc == OpCode.jrz || oc == OpCode.jrnz || \
        oc == OpCode.jrgz || oc == OpCode.jrlz || \
        oc == OpCode.jrge || oc == OpCode.jrle:
        argTypes[0] = ArgType.plainReg
        argTypes[1] = ArgType.offsetReg
        argTypes[2] = ArgType.none
    elif oc == OpCode.st:
        argTypes[0] = ArgType.offsetReg
        argTypes[1] = ArgType.offsetReg
        argTypes[2] = ArgType.none
    elif oc == OpCode.ld:
        argTypes[0] = ArgType.plainReg
        argTypes[1] = ArgType.offsetReg
        argTypes[2] = ArgType.none
    elif oc == OpCode.lui:
        argTypes[0] = ArgType.plainReg
        argTypes[1] = ArgType.imm
        argTypes[2] = ArgType.none
    elif oc == OpCode.lli:
        argTypes[0] = ArgType.plainReg
        argTypes[1] = ArgType.imm
        argTypes[2] = ArgType.none
    elif oc == OpCode.li:
        argTypes[0] = ArgType.plainReg
        argTypes[1] = ArgType.imm
        argTypes[2] = ArgType.none
    else:
        handleMsgError("error (internal): unknown opcode!")
        return null

    return argTypes

fn<u64> lineCount(std.String const* code):
    var<u64> count = 1
    var<u64> i = 0
    var<u64> codeLength = code->length()
    while i < codeLength:
        if code->at(i) == '\n':
            ++count
        ++i
    return count

pack AssemblerData:
    var<std.String const*> code
    var<std.String const*> filename
    var<bool> verbose
    var<u64> line
    var<u64> column
    var<u64> codeIndex
    var<u64> codeLength
    var<u64*> pnInstructions
    var<u32*> instructions
    var<bool> errorOccurred
    var<std.String*> entrypointName

fn<bool> parseWhitespace(AssemblerData* data):
    var<bool> parsedWhitespace = false
    while std.isspace(data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        parsedWhitespace = true

    return parsedWhitespace

fn<bool> parseExact(AssemblerData* data, u8 const* str):
    var<u64> i = 0
    var<u64> strLength = std.strlen(str)
    while i < strLength:
        if data->code->at(data->codeIndex + i) != str[i]:
            return false
        ++i
    data->codeIndex += strLength
    data->column += strLength
    return true

fn<bool> parseNewline(AssemblerData* data):
    if data->code->at(data->codeIndex) != '\n':
        return false

    ++data->codeIndex
    ++data->line
    data->column = 1
    return true

fn<bool> parseEntrypoint(AssemblerData* data):
    if data->code->at(data->codeIndex) != '.':
        return false

    if !parseExact(data, ".entry"):
        handleAsmError("Expected 'entry' after '.'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    if !parseWhitespace(data):
        handleAsmError("Expected whitespace after '.entry'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    var<u8> c
    var name = std.new(std.String)
    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    if name->length() == 0:
        handleAsmError("Expected entrypoint name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("Expected newline after entrypoint name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    data->entrypointName = name
    
    return true

fn<bool> parseLabel(AssemblerData* data):
    if data->code->at(data->codeIndex) != ':':
        return false
    ++data->codeIndex
    ++data->column
    if data->code->at(data->codeIndex) != ':':
        handleAsmError("Expected ':' after ':'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    ++data->codeIndex
    ++data->column

    var<u8> c
    var name = std.new(std.String)

    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        name->push_back(c)

    if name->length() == 0:
        handleAsmError("Expected label name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("Expected newline after label name!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    \\ TODO: Add label to symbol table

    return true

fn<OpCode> parseOpCode(AssemblerData* data):
    var oldIndex = data->codeIndex

    var insStr = std.new(std.String)
    var<u8> c
    while std.isalnum(c = data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        insStr->push_back(c)

    var opCode = opCodeFromStr(insStr)
    std.delete(insStr)

    if opCode == OpCode.none:
        data->codeIndex = oldIndex
        data->column -= data->codeIndex - oldIndex
        return OpCode.none

    return opCode

fn<bool> parseInstruction(AssemblerData* data):
    var opCode = parseOpCode(data)
    if opCode == OpCode.none:
        return false

    var argTypes = argTypesFromOpCode(opCode)
    var<u64> argIndex = 0

    while argTypes[argIndex] != ArgType.none:
        if !parseWhitespace(data):
            handleAsmError("Expected leading whitespace for instruction argument!", data->filename, data->line, data->column, data->instructions)
            data->errorOccurred = true
            return false
        ++argIndex

        \\ TODO: Parse instruction arguments

    return false

    return true

fn<bool> parseComment(AssemblerData* data):
    if data->code->at(data->codeIndex) != '~':
        return false
    
    ++data->codeIndex
    ++data->column
    if data->code->at(data->codeIndex) != '~':
        handleAsmError("Expected '~' after '~'!", data->filename, data->line, data->column, data->instructions)
        data->errorOccurred = true
        return false

    ++data->codeIndex
    ++data->column

    var<u8> c

    while (c = data->code->at(data->codeIndex)) != '\n' && c != '\0':
        ++data->codeIndex
        ++data->column

    parseNewline(data)

    return true



fn<u32*> assemble(std.String const* code, std.String const* filename, bool verbose, u64* pnInstructionsOut):
    var<AssemblerData> data
    data.code = code
    data.filename = filename
    data.verbose = verbose
    data.line = 1
    data.column = 1
    data.codeIndex = 0
    data.codeLength = code->length()
    data.pnInstructions = pnInstructionsOut
    *data.pnInstructions = 0
    data.errorOccurred = false
    data.entrypointName = null

    var buffSize = lineCount(code) * 4
    if verbose: std.println("Allocating % bytes of instruction memory...", buffSize)
    data.instructions = (u32*)std.malloc(buffSize)
    if data.instructions == null:
        handleMsgError("Failed to allocate instruction memory")
        return null

    while data.codeIndex < data.codeLength:
        parseWhitespace(&data)

        if parseNewline(&data): continue
        if data.errorOccurred: break
        
        if parseEntrypoint(&data): continue
        if data.errorOccurred: break
        
        if parseLabel(&data): continue
        if data.errorOccurred: break
        
        if parseInstruction(&data): continue
        if data.errorOccurred: break
        
        if parseComment(&data): continue
        if data.errorOccurred: break
        
        return handleAsmError("Unexpected character!", data.filename, data.line, data.column, data.instructions)
    
    if data.errorOccurred:
        std.free(data.instructions)
        return null

    return data.instructions