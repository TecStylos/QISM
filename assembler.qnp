import "string.qnp"
import "stdio.qnp"
import "map.qnp"
import "list.qnp"

import "errorhandler.qnp"

import "instructionHelpers.qnp"
import "stringToSevenSegment.qnp"

pack ArgParseData:
    var<RegID> register
    var<bool> hasOffset
    var<bool> offsetAlreadyUsed

pack ParityInstruction:
    var<u32> line
    var<u32> instruction

pack AssemblerData:
    var<std.String const*> code
    var<std.String const*> filename
    var<bool> verbose
    var<bool> addAnnotations
    var<u64> line
    var<u64> column
    var<u64> codeIndex
    var<u64> codeLength
    var<u64> nInstructions
    var<u32*> instructions
    var<ParityInstruction*> parityInstructions
    var<std.String**> annotations
    var<std.String*> entrypointName
    var<std.Map*> labels
    var<std.List*> literals



fn<> freeAsmData(AssemblerData* data):
    std.free(data->instructions)
    std.free(data->entrypointName)
    if data->annotations != null:
        var i = 0
        while i < data->nInstructions:
            std.delete(data->annotations[i])
            ++i
        std.free(data->annotations)

fn<u64> lineCount(std.String const* code) nodiscard:
    var<u64> count = 1
    var<u64> i = 0
    var<u64> codeLength = code->length()
    while i < codeLength:
        if code->at(i) == '\n':
            ++count
        ++i
    return count

fn<> writeInsPart(AssemblerData* data, ?T part, u32 mask, u32 offset):
    var<u32> overlap = data->parityInstructions[data->nInstructions].instruction & (mask << offset)
    if overlap != 0:
        handleAsmError("(internal): instruction bit overlap! (overlap: %b+8f0 %b+8f0 %b+8f0 %b+8f0)", data->filename, data->line, data->column, data->instructions, (overlap >> 24) & 0xFF, (overlap >> 16) & 0xFF, (overlap >> 8) & 0xFF, overlap & 0xFF)
        std.exit(1)

    var rawPart = (u32)part
    var writablePart = (rawPart & mask) << offset
    
    var instr = data->instructions[data->nInstructions]
    instr &= ~(mask << offset)
    instr |= writablePart
    data->instructions[data->nInstructions] = instr
    data->parityInstructions[data->nInstructions].instruction |= mask << offset

fn<> writeInsOpCode(AssemblerData* data, OpCode oc):
    writeInsPart(data, oc, 0b11111, 0)

fn<> writeInsDestReg(AssemblerData* data, RegID rid):
    writeInsPart(data, rid, 0b1111, 5)

fn<> writeInsCondition(AssemblerData* data, CondID cid):
    if cid == CondID.none:
        handleAsmError("unknown condition!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    writeInsPart(data, cid, 0b1111, 5)

fn<> writeInsOffsetSelect(AssemblerData* data, i32 os):
    writeInsPart(data, os, 0b1, 9)

fn<> writeInsOffset(AssemblerData* data, i32 offset, OffsetType ot):    
    if ot == OffsetType.normal:
        writeInsPart(data, offset, 0b11111111111111, 18)
    elif ot == OffsetType.short:
        writeInsPart(data, offset, 0b1111111111111, 18)
    elif ot == OffsetType.longContinuous:
        writeInsPart(data, offset, 0b111111111111111111, 14)
    elif ot == OffsetType.longSplit:
        writeInsPart(data, offset, 0b1111, 5)
        writeInsPart(data, offset >> 4, 0b11111111111111, 18)
    else:
        handleAsmError("unknown offset type %!", data->filename, data->line, data->column, data->instructions, (i32)ot)
        std.exit(1)

fn<> writeInsAutoFillOffset(AssemblerData* data, ArgParseData const* apd, OffsetType ot):
    if apd->offsetAlreadyUsed:
        return
    
    writeInsOffsetSelect(data, 0)
    writeInsOffset(data, 0, ot)

fn<> writeInsSourceReg1(AssemblerData* data, ArgParseData const* apd):
    writeInsPart(data, apd->register, 0b1111, 10)
    if apd->hasOffset:
        writeInsOffsetSelect(data, 0b0)

fn<> writeInsSourceReg2(AssemblerData* data, ArgParseData const* apd):
    writeInsPart(data, apd->register, 0b1111, 14)
    if apd->hasOffset:
        writeInsOffsetSelect(data, 0b1)

fn<> writeInsRelativeJump(AssemblerData* data, i32 rj):
    writeInsPart(data, rj, 0b1, 31)

fn<> writeInsImmediateFull(AssemblerData* data, i32 imm):
    writeInsPart(data, imm, 0b11111111111111111111111, 9)

fn<> writeInsImmediatePartial(AssemblerData* data, i32 imm):
    writeInsPart(data, imm, 0b1111111111111111, 16)

fn<> writeInsUnused(AssemblerData* data, u32 mask, u32 offset):
    writeInsPart(data, 0, mask, offset)

fn<bool> parseWhitespace(AssemblerData* data):
    var<bool> parsedWhitespace = false
    while std.isspace(data->code->at(data->codeIndex)):
        ++data->codeIndex
        ++data->column
        parsedWhitespace = true

    return parsedWhitespace

fn<bool> parseExact(AssemblerData* data, u8 const* str) nodiscard:
    var<u64> i = 0
    var<u64> strLength = std.strlen(str)
    while i < strLength:
        if data->code->at(data->codeIndex + i) != str[i]:
            return false
        ++i
    data->codeIndex += strLength
    data->column += strLength
    return true

fn<bool> parseNewline(AssemblerData* data) nodiscard:
    if data->code->at(data->codeIndex) != '\n':
        return false

    ++data->codeIndex
    ++data->line
    data->column = 1
    return true

fn<std.String*> parseAlNum(AssemblerData* data, bool allowNegative) nodiscard:
    var str = std.new(std.String)

    if allowNegative && data->code->at(data->codeIndex) == '-':
        str->push_back('-')
        ++data->codeIndex
        ++data->column

    var<u8> c
    while std.isalnum(c = data->code->at(data->codeIndex)):
        str->push_back(c)
        ++data->codeIndex
        ++data->column

    return str

fn<bool> parseEntrypoint(AssemblerData* data) nodiscard:
    if !parseExact(data, "."):
        return false

    if !parseExact(data, "entry"):
        handleAsmError("expected 'entry' after '.'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    if data->entrypointName != null:
        handleAsmError("entrypoint already defined!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    if !parseWhitespace(data):
        handleAsmError("expected whitespace after '.entry'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var name = parseAlNum(data, false)

    if name->length() == 0:
        handleAsmError("expected entrypoint name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after entrypoint name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    data->entrypointName = name

    if data->verbose:
        std.println("  info: entrypoint set to '%'", name->raw())
    
    return true

fn<bool> parseLabel(AssemblerData* data) nodiscard:
    if !parseExact(data, ":"):
        return false
    
    if !parseExact(data, ":"):
        handleAsmError("expected ':' after ':'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var name = parseAlNum(data, false)

    if name->length() == 0:
        handleAsmError("expected label name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    parseWhitespace(data)
    if !parseNewline(data):
        handleAsmError("expected newline after label name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var<u32> address = data->nInstructions * 4

    if data->labels->contains(name):
        handleAsmError("label '%' already defined!", data->filename, data->line, data->column, data->instructions, name->raw())
        std.exit(1)

    data->labels->insert(name, (void*)address)

    if data->verbose:
        std.println("  info: label '%' has address 0x%x", name->raw(), address)

    return true

fn<InsCode> parseInsCode(AssemblerData* data) nodiscard:
    var oldIndex = data->codeIndex
    var oldColumn = data->column

    var insStr = parseAlNum(data, false)

    var insCode = insCodeFromStr(insStr)
    std.delete(insStr)

    if insCode == InsCode.none:
        data->codeIndex = oldIndex
        data->column = oldColumn
        return InsCode.none

    return insCode

fn<> parseReg(AssemblerData* data, ArgParseData* apd):
    if !parseWhitespace(data):
        handleAsmError("Expected whitespace before register name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var name = parseAlNum(data, false)

    apd->register = regIDFromStr(name)
    std.delete(name)

    if apd->register == RegID.none:
        handleAsmError("expected register name!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    apd->hasOffset = false

fn<LiteralInfo*> makeLitInfo(AssemblerData const* data, LiteralInsertMode lim):
    var li = (LiteralInfo*)std.malloc(sizeof(LiteralInfo))
    li->mode = LiteralMode.Default
    li->insertMode = lim
    li->insIndex = data->nInstructions
    li->line = data->line
    li->column = data->column
    li->label = null
    return li

fn<> parseLiteral(AssemblerData* data, LiteralInsertMode lim):
    var litInfo = makeLitInfo(data, lim)

    var str = parseAlNum(data, true)

    if str->equals("upr"):
        litInfo->mode = LiteralMode.Upper
        std.delete(str)
        if !parseWhitespace(data):
            handleAsmError("expected whitespace after 'upr'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        str = parseAlNum(data, true)
    elif str->equals("lwr"):
        litInfo->mode = LiteralMode.Lower
        std.delete(str)
        if !parseWhitespace(data):
            handleAsmError("expected whitespace after 'lwr'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        str = parseAlNum(data, true)
    elif str->equals("rel"):
        litInfo->mode = LiteralMode.Relative
        std.delete(str)
        if !parseWhitespace(data):
            handleAsmError("expected whitespace after 'rel'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        str = parseAlNum(data, true)
    elif str->equals("sts"):
        std.delete(str)
        litInfo->mode = LiteralMode.Default
        parseWhitespace(data)
        if !parseExact(data, "\""):
            handleAsmError("expected '\"' after 'sts'!", data->filename, data->line, data->column, data->instructions)
            std.exit(1)
        var strLit = std.new(std.String)
        while !parseExact(data, "\""):
            strLit->push_back(data->code->at(data->codeIndex))
            if ++data->codeIndex >= data->codeLength:
                handleAsmError("expected '\"' after string literal!", data->filename, data->line, data->column, data->instructions)
                std.exit(1)

        str = std.new(std.String, "0b")

        var i = 0
        while i < strLit->length():
            var part = stringToSevenSegment(strLit->at(i))
            if part == null:
                handleAsmError("unable to convert '%' to seven segment format!", data->filename, data->line, data->column, data->instructions, strLit->at(i))
            str->append(part)
            ++i

    if str->length() == 0:
        handleAsmError("expected literal!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)
    elif std.isalpha(str->at(0)):
        litInfo->label = str
    else:
        std.error.clear()

        if str->beginswith("0x"):
            litInfo->value = std.stoi(str->raw() + 2, 16)
        elif str->beginswith("0b"):
            litInfo->value = std.stoi(str->raw() + 2, 2)
        elif str->beginswith("0"):
            litInfo->value = std.stoi(str->raw() + 1, 8)
        else:
            litInfo->value = std.stoi(str->raw(), 10)

        if std.error.get() != std.error.ID.Success:
            handleAsmError("invalid literal '%'", data->filename, data->line, data->column, data->instructions, str->raw())
            std.exit(1)

    data->literals->push_back(litInfo)

fn<> parseRegOffset(AssemblerData* data, ArgParseData* apd, OffsetType ot):
    parseReg(data, apd)

    if !parseExact(data, "("):
        apd->hasOffset = false
        return

    if apd->offsetAlreadyUsed:
        handleAsmError("instructions may not have more than one offset specified!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    apd->offsetAlreadyUsed = true
    apd->hasOffset = true
    parseLiteral(data, litInsModeFromOffsetType(ot))

    if !parseExact(data, ")"):
        handleAsmError("expected ')' after offset!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

fn<> parseInstructionThreeArg(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    parseReg(data, &apd)
    writeInsDestReg(data, apd.register)
    
    parseRegOffset(data, &apd, OffsetType.normal)
    writeInsSourceReg1(data, &apd)

    parseRegOffset(data, &apd, OffsetType.normal)
    writeInsSourceReg2(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.normal)

fn<> parseInstructionCondBranch(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    writeInsCondition(data, conditionFromInsCode(ic))

    parseRegOffset(data, &apd, OffsetType.short)
    writeInsSourceReg1(data, &apd)

    parseRegOffset(data, &apd, OffsetType.short)
    writeInsSourceReg2(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.short)

    if isRelativeJump(ic):
        writeInsRelativeJump(data, 1)
    else:
        writeInsRelativeJump(data, 0)

fn<> parseInstructionMemRead(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false

    parseReg(data, &apd)
    writeInsDestReg(data, apd.register)

    parseRegOffset(data, &apd, OffsetType.longContinuous)
    writeInsSourceReg1(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.longContinuous)

fn<> parseInstructionMemWrite(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false
    
    parseRegOffset(data, &apd, OffsetType.longSplit)
    writeInsSourceReg1(data, &apd)
    
    parseRegOffset(data, &apd, OffsetType.longSplit)
    writeInsSourceReg2(data, &apd)

    writeInsAutoFillOffset(data, &apd, OffsetType.longSplit)

fn<> parseImmediateFull(AssemblerData* data, ArgParseData* apd):
    if !parseWhitespace(data):
        handleAsmError("expected whitespace before immediate!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)
    parseLiteral(data, LiteralInsertMode.imm23)

fn<> parseImmediatePartial(AssemblerData* data, ArgParseData* apd):
    if !parseWhitespace(data):
        handleAsmError("expected whitespace before immediate!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)
    parseLiteral(data, LiteralInsertMode.imm16)

fn<> parseInstructionImmLoadFull(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false
    
    parseReg(data, &apd)
    writeInsDestReg(data, apd.register)

    parseImmediateFull(data, &apd)

fn<> parseInstructionImmLoadPartial(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false
    
    parseReg(data, &apd)
    writeInsDestReg(data, apd.register)

    writeInsSourceReg1(data, &apd)

    parseImmediatePartial(data, &apd)

    writeInsUnused(data, 0b11, 14)
    writeInsUnused(data, 0b1, 9)

fn<> parseInstructionAlias(AssemblerData* data, InsCode ic):
    var<ArgParseData> apd
    apd.register = RegID.none
    apd.hasOffset = false
    apd.offsetAlreadyUsed = false
    
    if ic == InsCode.int:
        writeInsOpCode(data, OpCode.int)
        parseImmediateFull(data, &apd)
        writeInsDestReg(data, RegID.zero)
    elif ic == InsCode.not:
        writeInsOpCode(data, OpCode.xor)

        parseReg(data, &apd)
        writeInsDestReg(data, apd.register)
        parseReg(data, &apd)
        writeInsSourceReg1(data, &apd)

        apd.register = RegID.zero
        apd.hasOffset = true
        apd.offsetAlreadyUsed = true
        writeInsSourceReg2(data, &apd)

        writeInsOffset(data, -1, OffsetType.normal)
    elif ic == InsCode.neg:
        writeInsOpCode(data, OpCode.sub)

        parseReg(data, &apd)
        writeInsDestReg(data, apd.register)

        apd.register = RegID.zero
        apd.hasOffset = false
        apd.offsetAlreadyUsed = false
        writeInsSourceReg1(data, &apd)

        parseRegOffset(data, &apd, OffsetType.normal)
        writeInsSourceReg2(data, &apd)

        writeInsAutoFillOffset(data, &apd, OffsetType.normal)
    elif ic == InsCode.inc:
        writeInsOpCode(data, OpCode.add)

        parseReg(data, &apd)
        writeInsDestReg(data, apd.register)

        parseReg(data, &apd)
        writeInsSourceReg1(data, &apd)

        apd.register = RegID.zero
        apd.hasOffset = true
        apd.offsetAlreadyUsed = true
        writeInsSourceReg2(data, &apd)

        writeInsOffset(data, 1, OffsetType.normal)
    elif ic == InsCode.dec:
        writeInsOpCode(data, OpCode.sub)

        parseReg(data, &apd)
        writeInsDestReg(data, apd.register)

        parseReg(data, &apd)
        writeInsSourceReg1(data, &apd)

        apd.register = RegID.zero
        apd.hasOffset = true
        apd.offsetAlreadyUsed = true
        writeInsSourceReg2(data, &apd)

        writeInsOffset(data, 1, OffsetType.normal)
    elif ic == InsCode.jmp:
        writeInsOpCode(data, OpCode.jxx)

        writeInsCondition(data, CondID.z)

        parseRegOffset(data, &apd, OffsetType.short)
        writeInsSourceReg1(data, &apd)

        apd.register = RegID.zero
        apd.hasOffset = false
        writeInsSourceReg2(data, &apd)

        writeInsAutoFillOffset(data, &apd, OffsetType.short)

        writeInsRelativeJump(data, 0)
    elif ic == InsCode.jpr:
        writeInsOpCode(data, OpCode.jxx)

        writeInsCondition(data, CondID.z)

        parseRegOffset(data, &apd, OffsetType.short)
        writeInsSourceReg1(data, &apd)

        apd.register = RegID.zero
        apd.hasOffset = false
        writeInsSourceReg2(data, &apd)

        writeInsAutoFillOffset(data, &apd, OffsetType.short)

        writeInsRelativeJump(data, 1)
    elif ic == InsCode.mov:
        writeInsOpCode(data, OpCode.add)
        
        parseReg(data, &apd)
        writeInsDestReg(data, apd.register)

        parseRegOffset(data, &apd, OffsetType.normal)
        writeInsSourceReg1(data, &apd)

        apd.register = RegID.zero
        apd.hasOffset = false
        writeInsSourceReg2(data, &apd)

        writeInsAutoFillOffset(data, &apd, OffsetType.normal)
    else:
        handleAsmError("(internal): unknown alias instruction!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

fn<bool> parseInstruction(AssemblerData* data) nodiscard:
    var<u64> lineBegin = data->codeIndex

    var insCode = parseInsCode(data)
    if insCode == InsCode.none:
        return false

    var opCode = opCodeFromInsCode(insCode)
    data->parityInstructions[data->nInstructions].line = data->line
    data->parityInstructions[data->nInstructions].instruction = 0
    
    if opCode != OpCode.insAlias:
        writeInsOpCode(data, opCode)

    var insType = insTypeFromOpCode(opCode)
    if insType == InsType.threeArg:
        parseInstructionThreeArg(data, insCode)
    elif insType == InsType.condBranch:
        parseInstructionCondBranch(data, insCode)
    elif insType == InsType.memRead:
        parseInstructionMemRead(data, insCode)
    elif insType == InsType.memWrite:
        parseInstructionMemWrite(data, insCode)
    elif insType == InsType.immLoadFull:
        parseInstructionImmLoadFull(data, insCode)
    elif insType == InsType.immLoadLower || insType == InsType.immLoadUpper:
        parseInstructionImmLoadPartial(data, insCode)
    elif insType == InsType.insAlias:
        parseInstructionAlias(data, insCode)
    else:
        handleAsmError("(internal): instruction type not implemented!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var<u64> lineEnd = data->codeIndex

    if data->addAnnotations:
        data->annotations[data->nInstructions] = std.new(std.String, data->code->raw() + lineBegin, lineEnd - lineBegin)
    ++data->nInstructions

    if !parseNewline(data):
        handleAsmError("expected newline after instruction", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    return true

fn<bool> parseComment(AssemblerData* data) nodiscard:
    if !parseExact(data, "~"):
        return false

    if !parseExact(data, "~"):
        handleAsmError("expected '~' after '~'!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    while data->code->at(data->codeIndex) != '\n':
        ++data->codeIndex
        ++data->column

    if !parseNewline(data):
        handleAsmError("expected newline after comment", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    return true

fn<> checkLiteralRange(i32 value, LiteralInsertMode lim, AssemblerData* data, u32 line, u32 column):
    var<i32> minVal = 0
    var<i32> maxVal = 0

    if lim == LiteralInsertMode.imm16:
        minVal = -32768 \\ -2 ** 15
        maxVal =  32767 \\ 2 ** 15 - 1
    elif lim == LiteralInsertMode.imm23:
        minVal = -4194304 \\ -2 ** 22
        maxVal =  4194303 \\ 2 ** 22 - 1
    elif lim == LiteralInsertMode.offNormal:
        minVal = -8192 \\  -2 ** 13
        maxVal =  8191 \\   2 ** 13 - 1
    elif lim == LiteralInsertMode.offShort:
        minVal = -4096 \\  -2 ** 12
        maxVal =  4095 \\   2 ** 12 - 1
    elif lim == LiteralInsertMode.offLongContinuous || \
        lim == LiteralInsertMode.offLongSplit:
        minVal = -131072 \\  -2 ** 17
        maxVal =  131071 \\   2 ** 17 - 1
    else:
        handleAsmError("(internal): literal insert mode not implemented!", data->filename, line, column, data->instructions)
        std.exit(1)


    if value < minVal || value > maxVal:
        handleAsmError("literal value '%' out of range (% to %)", data->filename, line, column, data->instructions, value, minVal, maxVal)
        std.exit(1)

fn<i32> extendLiteralValue(AssemblerData* data, i32 val, LiteralInsertMode lim) nodiscard:
    var<u32> mask
    var<u32> msb
    if lim == LiteralInsertMode.imm16:
        mask = 0b11111111111111110000000000000000
        msb = 15
    elif lim == LiteralInsertMode.imm23:
        mask = 0b11111111100000000000000000000000
        msb = 22
    elif lim == LiteralInsertMode.offNormal:
        mask = 0b11111111111111111100000000000000
        msb = 13
    elif lim == LiteralInsertMode.offShort:
        mask = 0b11111111111111111110000000000000
        msb = 12
    elif lim == LiteralInsertMode.offLongContinuous || \
        lim == LiteralInsertMode.offLongSplit:
        mask = 0b11111111111111000000000000000000
        msb = 17
    else:
        handleAsmError("(internal): literal insert mode not implemented!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    var allZeroes = (val & mask) == 0
    var msbIsSet = ((val >> msb) & 1) == 1

    if allZeroes && msbIsSet:
        val |= mask
    
    return val


fn<> insertLiterals(AssemblerData* data):
    var nInstructionsBackup = data->nInstructions

    while !data->literals->empty():
        var litInfo = data->literals->pop_front({LiteralInfo*})

        data->line = litInfo->line
        data->column = litInfo->column
        data->nInstructions = litInfo->insIndex

        var<i32> value = litInfo->value
        if litInfo->label != null:
            if data->labels->contains(litInfo->label):
                value = (i32)data->labels->get(litInfo->label)
            else:
                handleAsmError("label '%' not found", data->filename, data->line, data->column, data->instructions, litInfo->label->raw())
                std.exit(1)

        if litInfo->mode == LiteralMode.Upper:
            value = (value >> 16) & 0xFFFF
        elif litInfo->mode == LiteralMode.Lower:
            value = value & 0xFFFF
        elif litInfo->mode == LiteralMode.Relative:
            value = value - (data->nInstructions * 4)


        value = extendLiteralValue(data, value, litInfo->insertMode)
        checkLiteralRange(value, litInfo->insertMode, data, data->line, data->column)

        if litInfo->insertMode == LiteralInsertMode.imm16:
            writeInsImmediatePartial(data, value)
        elif litInfo->insertMode == LiteralInsertMode.imm23:
            writeInsImmediateFull(data, value)
        else:
            writeInsOffset(data, value, offsetTypeFromLitInsMode(litInfo->insertMode))

        std.free(litInfo)

    std.delete(data->literals)
    data->nInstructions = nInstructionsBackup

fn<> checkParity(AssemblerData* data):
    \\ Check parity of all instructions
    var i = 0
    while i < data->nInstructions:
        var instruction = data->parityInstructions[i].instruction
        if instruction != 0xFFFFFFFF:
            handleAsmError("(internal): parity bit mismatch! (%b+8f0 %b+8f0 %b+8f0 %b+8f0 -- 0 indicates unset bit)", data->filename, data->parityInstructions[i].line, 1, data->instructions, (instruction >> 24) & 0xFF, (instruction >> 16) & 0xFF, (instruction >> 8) & 0xFF, instruction & 0xFF)
            std.exit(1)
        ++i
    std.free(data->parityInstructions)

fn<> assemble(AssemblerData* data):
    data->line = 1
    data->column = 1
    data->codeIndex = 0
    data->codeLength = data->code->length()
    data->nInstructions = 0
    data->instructions = null
    data->annotations = null
    data->entrypointName = null
    data->labels = std.new(std.Map, \
        lambda<bool>(void const* a, void const* b): \
            return ((std.String const*)a)->compare((std.String const*)b) == std.Order.Less;, \
        lambda<void>(void* key): \
            std.delete((std.String*)key);, \
        lambda<void>(void* value): \
            pass; \
        )
    data->literals = std.new(std.List)

    var lc = lineCount(data->code)
    var instrBuffSize = lc * 4
    if data->verbose: std.println("  info: allocating % bytes of instruction memory...", instrBuffSize)
    data->instructions = (u32*)std.malloc(instrBuffSize)
    if data->instructions == null:
        handleMsgError("failed to allocate instruction memory")
        std.exit(1)

    var parityBuffSize = lc * sizeof(ParityInstruction)
    if data->verbose: std.println("  info: allocating % bytes of parity instruction memory...", parityBuffSize)
    data->parityInstructions = (ParityInstruction*)std.malloc(parityBuffSize)
    if data->parityInstructions == null:
        handleMsgError("failed to allocate parity instruction memory")
        std.exit(1)

    if data->addAnnotations:
        var annotBuffSize = lc * sizeof(std.String*)
        if data->verbose: std.println("  info: allocating % bytes of annotation memory...", annotBuffSize)
        data->annotations = (std.String**)std.malloc(annotBuffSize)
        if data->annotations == null:
            handleMsgError("failed to allocate instruction line memory")
            std.exit(1)

    while data->codeIndex < data->codeLength:
        parseWhitespace(data)

        if parseNewline(data): continue
        if parseEntrypoint(data): continue
        if parseLabel(data): continue
        if parseInstruction(data): continue
        if parseComment(data): continue
        
        handleAsmError("unexpected character!", data->filename, data->line, data->column, data->instructions)
        std.exit(1)

    if data->entrypointName == null:
        handleMsgError("no entrypoint specified!")
        std.exit(1)

    if data->verbose: std.println("  info: # of instructions: %", data->nInstructions)

    if data->verbose: std.println("  info: inserting literals...")
    insertLiterals(data)

    if data->verbose: std.println("  info: checking parity...")
    checkParity(data)