import "outputformat.qnp"
import "fileio.qnp"

import "errorhandler.qnp"

fn<u8 const*> itos(i64 num, u8* buffer, i64 base, i64 width):
    var len = std.strlen(std.itos(num, buffer, base))
    var shiftBuffer = buffer
    while len < width:
        *shiftBuffer = '0'
        ++shiftBuffer
        ++len
        
    var _ = std.itos(num, shiftBuffer, base)

    return buffer

fn<u64> genInstructionBuffer(u8* buffer, u32 instruction, OutputFormat outputFormat):
    if outputFormat == OutputFormat.bin:
        buffer[0] = (instruction >> 24) & 0xFF
        buffer[1] = (instruction >> 16) & 0xFF
        buffer[2] = (instruction >> 8) & 0xFF
        buffer[3] = (instruction >> 0) & 0xFF
        return 4
    if outputFormat == OutputFormat.bintxt:
        var<u64> len = 0
        len += std.strlen(itos((instruction >> 24) & 0xFF, buffer + len, 2, 8))
        buffer[len++] = ' '
        len += std.strlen(itos((instruction >> 16) & 0xFF, buffer + len, 2, 8))
        buffer[len++] = ' '
        len += std.strlen(itos((instruction >> 8) & 0xFF, buffer + len, 2, 8))
        buffer[len++] = ' '
        len += std.strlen(itos((instruction >> 0) & 0xFF, buffer + len, 2, 8))
        buffer[len++] = '\n'
        return len
    if outputFormat == OutputFormat.hextxt:
        var<u64> len = 0
        len += std.strlen(itos((instruction >> 24) & 0xFF, buffer + len, 16, 2))
        buffer[len++] = ' '
        len += std.strlen(itos((instruction >> 16) & 0xFF, buffer + len, 16, 2))
        buffer[len++] = ' '
        len += std.strlen(itos((instruction >> 8) & 0xFF, buffer + len, 16, 2))
        buffer[len++] = ' '
        len += std.strlen(itos((instruction >> 0) & 0xFF, buffer + len, 16, 2))
        buffer[len++] = '\n'
        return len

    handleMsgError("Invalid output format!")
    return 0

fn<bool> writeToFile(std.String const* filename, u32 const* instructions, u64 nInstructions, OutputFormat outputFormat):
    var file = std.new(std.File, filename->raw(), "w")
    if file == null:
        return handleMsgError("Could not open output file for writing!")
    
    var<u64> i = 0
    var<u8[64]> buffer
    while i < nInstructions:
        var bufferSize = genInstructionBuffer(buffer, instructions[i], outputFormat)
        if bufferSize == 0:
            std.delete(file)
            return false

        if file->write(buffer, bufferSize) != bufferSize:
            std.delete(file)
            return handleMsgError("Could not write to output file!")
        ++i

    std.delete(file)

    return true